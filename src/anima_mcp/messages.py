"""
Message Board - Storage for observations and user messages.

Messages are stored persistently so they survive reboots.
"""

import json
import sys
import time
import os
import uuid
from typing import List, Dict, Any, Optional
from dataclasses import dataclass, asdict
from pathlib import Path


# Message types
MESSAGE_TYPE_OBSERVATION = "observation"  # Auto-generated by Lumen
MESSAGE_TYPE_QUESTION = "question"        # Questions from Lumen seeking response
MESSAGE_TYPE_USER = "user"                # Left by user via MCP tool
MESSAGE_TYPE_AGENT = "agent"              # Left by AI agents
MESSAGE_TYPE_SYSTEM = "system"            # System events


def _get_persistent_path() -> Path:
    """Get persistent path for messages - survives reboots."""
    # Use ~/.anima/ directory for persistent data
    anima_dir = Path.home() / ".anima"
    anima_dir.mkdir(exist_ok=True)
    return anima_dir / "messages.json"


@dataclass
class Message:
    """A message on the board."""
    message_id: str  # Unique ID for referencing
    text: str  # Clean text - no prefixes
    msg_type: str  # observation, user, agent, system, question
    timestamp: float
    author: Optional[str] = None  # "user", "lumen", "agent_name", etc.
    responds_to: Optional[str] = None  # message_id this responds to (for answers)
    answered: bool = False  # For questions: has this been answered?
    context: Optional[str] = None  # For questions: what triggered this question

    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

    @classmethod
    def from_dict(cls, d: Dict[str, Any]) -> "Message":
        # Handle old messages without message_id
        if "message_id" not in d:
            import uuid
            d["message_id"] = str(uuid.uuid4())[:8]
        if "author" not in d:
            d["author"] = None
        if "responds_to" not in d:
            d["responds_to"] = None
        if "answered" not in d:
            d["answered"] = False
        if "context" not in d:
            d["context"] = None
        return cls(**d)

    def is_question(self) -> bool:
        """Check if this message is a question."""
        return self.msg_type == MESSAGE_TYPE_QUESTION

    def age_str(self) -> str:
        """Human-readable age string."""
        age_seconds = time.time() - self.timestamp
        if age_seconds < 60:
            return "now"
        elif age_seconds < 3600:
            mins = int(age_seconds / 60)
            return f"{mins}m ago"
        elif age_seconds < 86400:
            hours = int(age_seconds / 3600)
            return f"{hours}h ago"
        else:
            days = int(age_seconds / 86400)
            return f"{days}d ago"


class MessageBoard:
    """Message board storage with separate limits per message type."""

    # Separate limits prevent observations from pushing out questions/visitors
    MAX_OBSERVATIONS = 100  # Lumen's self-talk (frequent)
    MAX_QUESTIONS = 50      # Curiosity questions (rare, important)
    MAX_VISITORS = 50       # User/agent messages (important to keep)

    def __init__(self):
        self._messages_file = _get_persistent_path()
        self._messages: List[Message] = []
        self._last_load_time: float = 0.0
        self._file_mtime: float = 0.0
        self._load()

    def _load(self, force: bool = False):
        """Load messages from persistent storage."""
        # Check file modification time - only reload if changed
        if not force and self._messages_file.exists():
            current_mtime = self._messages_file.stat().st_mtime
            if current_mtime == self._file_mtime and self._messages:
                return  # No change, skip reload
        
        try:
            if self._messages_file.exists():
                data = json.loads(self._messages_file.read_text())
                self._messages = [Message.from_dict(m) for m in data.get("messages", [])]
                self._file_mtime = self._messages_file.stat().st_mtime
            else:
                self._messages = []
                self._file_mtime = 0.0
        except Exception as e:
            print(f"[MessageBoard] Load error: {e}", file=sys.stderr, flush=True)
            self._messages = []
            self._file_mtime = 0.0

    def _save(self):
        """Save messages to persistent storage."""
        try:
            data = {"messages": [m.to_dict() for m in self._messages]}
            self._messages_file.write_text(json.dumps(data))
            # Update mtime tracking after save
            if self._messages_file.exists():
                self._file_mtime = self._messages_file.stat().st_mtime
        except Exception as e:
            print(f"[MessageBoard] Save error: {e}", file=sys.stderr, flush=True)

    def add_message(self, text: str, msg_type: str = MESSAGE_TYPE_OBSERVATION, author: Optional[str] = None) -> Message:
        """Add a message to the board."""
        message_id = str(uuid.uuid4())[:8]  # Short unique ID
        msg = Message(
            message_id=message_id,
            text=text,  # Clean text - no prefixes
            msg_type=msg_type,
            timestamp=time.time(),
            author=author,
        )
        self._messages.append(msg)

        # Trim by type - each category has its own limit
        self._trim_by_type()

        self._save()
        return msg

    def _trim_by_type(self):
        """Trim messages by type, preserving limits for each category.

        IMPORTANT: Preserves agent messages that are answers to questions (have responds_to)
        to maintain Q&A consistency. Without this, answered questions would show as
        'expired' when their answer messages get trimmed.
        """
        # Separate messages by type
        observations = [m for m in self._messages if m.msg_type == MESSAGE_TYPE_OBSERVATION]
        questions = [m for m in self._messages if m.msg_type == MESSAGE_TYPE_QUESTION]

        # Get question IDs for checking responds_to links
        question_ids = {q.message_id for q in questions}

        # Separate visitors into answers (must preserve) and regular messages
        visitors = [m for m in self._messages if m.msg_type in (MESSAGE_TYPE_USER, MESSAGE_TYPE_AGENT)]
        answers = [m for m in visitors if m.responds_to and m.responds_to in question_ids]
        regular_visitors = [m for m in visitors if not (m.responds_to and m.responds_to in question_ids)]

        # Trim each category to its limit (keep most recent)
        observations = observations[-self.MAX_OBSERVATIONS:]
        questions = questions[-self.MAX_QUESTIONS:]
        # Keep all answers (capped at MAX_QUESTIONS since they map 1:1)
        # Trim regular visitors to fill remaining space
        answers = answers[-self.MAX_QUESTIONS:]
        regular_visitors = regular_visitors[-(self.MAX_VISITORS - len(answers)):]

        # Merge back and sort by timestamp
        self._messages = observations + questions + answers + regular_visitors
        self._messages.sort(key=lambda m: m.timestamp)

    def add_observation(self, text: str, author: str = "lumen") -> Message:
        """Add an auto-generated observation from Lumen.

        Deduplication strategy:
        1. Global rate limit: Max 1 observation per 5 minutes (prevents spam)
        2. Semantic similarity: Skip if >50% word overlap with recent obs
        3. Exact match: Skip identical text within 15 minutes
        """
        import time

        now = time.time()
        five_minutes_ago = now - 300
        fifteen_minutes_ago = now - 900

        # Get recent observations (last 20)
        recent_observations = [m for m in self._messages if m.msg_type == MESSAGE_TYPE_OBSERVATION][-20:]

        # === GLOBAL RATE LIMIT ===
        # Max 1 observation per 5 minutes to prevent chatter
        if recent_observations:
            last_obs = recent_observations[-1]
            if last_obs.timestamp > five_minutes_ago:
                return None  # Too soon since last observation

        # === EXACT MATCH CHECK ===
        for obs in recent_observations:
            if obs.text == text and obs.timestamp > fifteen_minutes_ago:
                return None  # Skip exact duplicate

        # === SEMANTIC SIMILARITY CHECK ===
        # Skip if new text is >50% similar to any recent observation
        def get_words(s: str) -> set:
            """Extract meaningful words (lowercase, no punctuation)."""
            import re
            # Remove punctuation, lowercase, split
            words = re.sub(r'[^\w\s]', '', s.lower()).split()
            # Filter out very short words and common filler
            stopwords = {'i', 'a', 'the', 'to', 'and', 'is', 'it', 'in', 'my', 'im', 'that', 'this'}
            return {w for w in words if len(w) > 2 and w not in stopwords}

        new_words = get_words(text)
        if new_words:  # Only check if we have meaningful words
            for obs in recent_observations[-10:]:  # Check last 10 observations
                obs_words = get_words(obs.text)
                if obs_words:
                    # Jaccard similarity
                    intersection = new_words & obs_words
                    union = new_words | obs_words
                    similarity = len(intersection) / len(union) if union else 0

                    if similarity > 0.50:  # More than 50% overlap
                        return None  # Too similar to recent observation

        return self.add_message(text, MESSAGE_TYPE_OBSERVATION, author=author)

    def add_user_message(self, text: str) -> Message:
        """Add a user message."""
        return self.add_message(text, MESSAGE_TYPE_USER, author="user")
    
    def add_agent_message(self, text: str, agent_name: str = "agent", responds_to: Optional[str] = None) -> Message:
        """Add an agent message, optionally responding to a question."""
        msg = self.add_message(text, MESSAGE_TYPE_AGENT, author=agent_name)
        if responds_to:
            # Validate that the question exists - require exact match
            question_text = None
            question_context = None
            question_timestamp = None
            question_found = False

            # First try exact match
            for m in self._messages:
                if m.message_id == responds_to and m.msg_type == MESSAGE_TYPE_QUESTION:
                    m.answered = True
                    question_text = m.text
                    question_context = getattr(m, 'context', None)
                    question_timestamp = m.timestamp
                    question_found = True
                    break
            
            # If exact match failed, try prefix matching for better UX
            if not question_found:
                matching_questions = [
                    m for m in self._messages
                    if m.msg_type == MESSAGE_TYPE_QUESTION
                    and m.message_id.startswith(responds_to)
                ]
                if len(matching_questions) == 1:
                    # Single match - use it
                    q = matching_questions[0]
                    q.answered = True
                    question_text = q.text
                    question_context = getattr(q, 'context', None)
                    question_timestamp = q.timestamp
                    question_found = True
                    # Update responds_to to full ID
                    responds_to = q.message_id
                    print(f"[MessageBoard] Matched partial ID '{responds_to[:8]}...' to question '{q.message_id}'", file=sys.stderr, flush=True)
                elif len(matching_questions) > 1:
                    # Multiple matches - ambiguous
                    print(f"[MessageBoard] WARNING: Partial ID '{responds_to}' matches {len(matching_questions)} questions. Use full ID.", file=sys.stderr, flush=True)
                    # Use the most recent one
                    q = matching_questions[-1]
                    q.answered = True
                    question_text = q.text
                    question_context = getattr(q, 'context', None)
                    question_timestamp = q.timestamp
                    question_found = True
                    responds_to = q.message_id
            
            # Set responds_to (now with validated full ID if prefix matched)
            msg.responds_to = responds_to
            
            if not question_found:
                # Question not found - warn but still save the message
                print(f"[MessageBoard] WARNING: Question ID '{responds_to}' not found. Answer saved but won't link to Q&A screen.", file=sys.stderr, flush=True)
                # Try to find similar IDs for helpful error
                all_question_ids = [m.message_id for m in self._messages if m.msg_type == MESSAGE_TYPE_QUESTION]
                similar = [qid for qid in all_question_ids if responds_to in qid or qid.startswith(responds_to[:4])]
                if similar:
                    print(f"[MessageBoard] Similar question IDs: {similar[:3]}", file=sys.stderr, flush=True)
            
            self._save()

            # Compute feedback for agency learning (was this question well-formed?)
            # Skip self-answers - Lumen answering own questions is circular learning
            if question_text and agent_name.lower() != "lumen":
                feedback = self._compute_question_feedback(question_text, text, question_context)
                if feedback:
                    try:
                        from .agency import get_action_selector
                        selector = get_action_selector()
                        selector.record_question_feedback(question_text, feedback)
                        print(f"[Feedback] Question '{question_text[:30]}...' got score {feedback['score']:.2f}", file=sys.stderr, flush=True)
                    except Exception as e:
                        pass  # Agency not available, that's fine
            elif question_text and agent_name.lower() == "lumen":
                print(f"[Feedback] Skipping self-answer feedback (circular learning)", file=sys.stderr, flush=True)
                # Record self-dialogue topic for self-knowledge tracking
                try:
                    from .growth import get_growth_system
                    growth = get_growth_system()
                    topic = growth.record_self_dialogue_topic(question_text)
                    print(f"[Self-knowledge] Self-dialogue topic: {topic}", file=sys.stderr, flush=True)
                except Exception as e:
                    print(f"[Self-knowledge] Topic recording failed: {e}", file=sys.stderr, flush=True)

            # Extract insight from Q&A â€” learn from the answer
            if question_text:
                try:
                    from .knowledge import add_insight, _extract_simple_insight, _categorize_text

                    # Synchronous rule-based extraction (always works, no LLM needed)
                    insight_text = _extract_simple_insight(question_text, text)
                    if insight_text:
                        category = _categorize_text(insight_text + " " + text)
                        insight = add_insight(
                            text=insight_text,
                            source_question=question_text,
                            source_answer=text,
                            source_author=agent_name,
                            category=category,
                        )
                        print(f"[Knowledge] Learned from Q&A: {insight.text}", file=sys.stderr, flush=True)
                    else:
                        print(f"[Knowledge] No extractable insight from answer (too short or acknowledgment)", file=sys.stderr, flush=True)
                except Exception as e:
                    print(f"[Knowledge] Insight extraction failed: {e}", file=sys.stderr, flush=True)

        return msg

    def _compute_question_feedback(self, question: str, response: str, context: Optional[str] = None) -> dict:
        """
        Compute feedback on question quality based on response.

        This is how Lumen learns which question patterns get engagement.
        Positive signals: long response, substantive content, no confusion markers
        Negative signals: short response, "don't understand", questions back
        """
        response_lower = response.lower()

        # Base score starts neutral
        score = 0.5
        signals = []

        # Positive signals
        if len(response) > 150:
            score += 0.15
            signals.append("long_response")
        if len(response) > 300:
            score += 0.1
            signals.append("very_long_response")

        # Negative signals - confusion/incompleteness markers
        confusion_markers = ["don't understand", "unclear", "incomplete", "what do you mean",
                           "not sure what", "could you clarify", "broken", "fragmented", "malformed"]
        for marker in confusion_markers:
            if marker in response_lower:
                score -= 0.2
                signals.append(f"confusion:{marker}")

        # Questions back = confusion
        if response.count("?") > 1:
            score -= 0.1
            signals.append("questions_back")

        # Agency-generated questions get scrutinized more
        if context and "agency" in context:
            # Agency questions start with lower baseline
            score -= 0.1
            signals.append("agency_generated")

        # Clamp score
        score = max(0.0, min(1.0, score))

        return {
            "score": score,
            "signals": signals,
            "response_length": len(response),
            "question_length": len(question),
        }

    def add_question(self, text: str, author: str = "lumen", context: Optional[str] = None) -> Optional[Message]:
        """Add a question from Lumen - seeking response from agents/user.

        Args:
            text: The question text
            author: Who is asking (default: "lumen")
            context: What triggered this question (e.g., "light dropped suddenly")
        """
        import time

        now = time.time()

        # Rate limit: minimum 3 minutes between questions (prevents backlog)
        MIN_QUESTION_INTERVAL = 180  # 3 minutes
        recent_questions = [m for m in self._messages if m.msg_type == MESSAGE_TYPE_QUESTION]
        if recent_questions:
            last_question_time = recent_questions[-1].timestamp
            if now - last_question_time < MIN_QUESTION_INTERVAL:
                return None  # Too soon since last question

        # Deduplication: Don't ask similar questions within 4 hours
        four_hours_ago = now - 14400

        for q in recent_questions[-20:]:
            if q.timestamp > four_hours_ago:
                # Check for exact or similar questions
                if self._questions_similar(text, q.text):
                    return None  # Skip similar question

        msg = self.add_message(text, MESSAGE_TYPE_QUESTION, author=author)
        if msg and context:
            msg.context = context
            self._save()
        return msg

    def _questions_similar(self, q1: str, q2: str) -> bool:
        """Check if two questions are similar (fuzzy matching).

        Returns True if questions are too similar to ask again.
        """
        # Normalize: lowercase, strip punctuation
        def normalize(s: str) -> str:
            return s.lower().strip().rstrip("?!.")

        n1, n2 = normalize(q1), normalize(q2)

        # Exact match after normalization
        if n1 == n2:
            return True

        # Check word overlap (Jaccard similarity > 0.6 = too similar)
        words1 = set(n1.split())
        words2 = set(n2.split())
        if not words1 or not words2:
            return n1 == n2

        intersection = words1 & words2
        union = words1 | words2
        jaccard = len(intersection) / len(union) if union else 0

        if jaccard > 0.6:
            return True

        # Check for common question stems (prevents "what connects X" repetition)
        stems = [
            "what connects",
            "why did so many",
            "what changed",
            "why did it get",
            "what caused",
            "how are these",
        ]
        for stem in stems:
            if stem in n1 and stem in n2:
                return True

        return False

    def get_unanswered_questions(self, limit: int = 5, auto_expire: bool = True) -> List[Message]:
        """Get unanswered questions for agents to respond to.

        Args:
            limit: Max questions to return
            auto_expire: If True, mark questions older than 4 hours as expired (answered=True)
        """
        self._load()

        # Auto-expire old questions so Lumen can ask new ones
        if auto_expire:
            now = time.time()
            four_hours_ago = now - 14400  # 4 hour expiry (was 1 hour)
            expired_any = False
            for m in self._messages:
                if (m.msg_type == MESSAGE_TYPE_QUESTION and
                    not m.answered and
                    m.timestamp < four_hours_ago):
                    m.answered = True  # Mark as expired/answered
                    expired_any = True
                    print(f"[Questions] Expired old question: {m.text[:50]}...", file=sys.stderr, flush=True)
            if expired_any:
                self._save()

        questions = [m for m in self._messages if m.msg_type == MESSAGE_TYPE_QUESTION and not m.answered]
        return questions[-limit:]

    def repair_orphaned_answered(self) -> int:
        """Fix questions marked 'answered' but with no actual answer message.

        This can happen when answer messages are trimmed but the question's
        answered flag remains True. Resets answered=False for questions
        that have no responds_to link pointing to them (except truly expired ones).

        Returns: Number of questions repaired.
        """
        self._load()

        # Find all answer links (responds_to pointing to questions)
        answered_ids = {
            m.responds_to for m in self._messages
            if m.msg_type == MESSAGE_TYPE_AGENT and m.responds_to
        }

        # Find orphaned questions (answered=True but no actual answer, and not expired by age)
        four_hours_ago = time.time() - 14400
        repaired = 0
        for m in self._messages:
            if (m.msg_type == MESSAGE_TYPE_QUESTION and
                m.answered and
                m.message_id not in answered_ids and
                m.timestamp >= four_hours_ago):  # Not old enough to be legitimately expired
                m.answered = False
                repaired += 1
                print(f"[MessageBoard] Repaired orphaned question: {m.text[:50]}...", file=sys.stderr, flush=True)

        if repaired:
            self._save()

        return repaired

    def get_recent_questions(self, hours: int = 24, limit: int = 100) -> List[Message]:
        """Get all questions (answered or not) from the last N hours.

        Used for deduplication - prevents asking the same question repeatedly.
        """
        self._load()
        cutoff = time.time() - (hours * 3600)
        questions = [
            m for m in self._messages
            if m.msg_type == MESSAGE_TYPE_QUESTION and m.timestamp > cutoff
        ]
        return questions[-limit:]

    def get_messages_for_lumen(self, since_timestamp: float = 0, limit: int = 5) -> List[Message]:
        """Get messages from agents/users that Lumen might want to respond to."""
        self._load()
        # Messages from others (not Lumen's own observations/questions)
        from_others = [
            m for m in self._messages
            if m.msg_type in (MESSAGE_TYPE_USER, MESSAGE_TYPE_AGENT)
            and m.timestamp > since_timestamp
            and m.author != "lumen"
        ]
        return from_others[-limit:]

    def get_recent(self, limit: int = 8, msg_type: Optional[str] = None) -> List[Message]:
        """Get recent messages, newest first."""
        self._load()  # Smart reload - only if file changed
        messages = self._messages[-limit:]
        if msg_type:
            messages = [m for m in messages if m.msg_type == msg_type]
        return list(reversed(messages))
    
    def get_by_id(self, message_id: str) -> Optional[Message]:
        """Get a specific message by ID."""
        self._load()
        for msg in self._messages:
            if msg.message_id == message_id:
                return msg
        return None
    
    def delete_by_id(self, message_id: str) -> bool:
        """Delete a message by ID."""
        self._load(force=True)
        original_count = len(self._messages)
        self._messages = [m for m in self._messages if m.message_id != message_id]
        if len(self._messages) < original_count:
            self._save()
            return True
        return False

    def clear(self):
        """Clear all messages."""
        self._messages = []
        self._save()


# Singleton instance
_board: Optional[MessageBoard] = None


def get_board() -> MessageBoard:
    """Get the message board singleton."""
    global _board
    if _board is None:
        _board = MessageBoard()
    return _board


def add_observation(text: str, author: str = "lumen") -> Optional[Message]:
    """Convenience: add an observation from Lumen."""
    return get_board().add_observation(text, author=author)


def add_user_message(text: str) -> Message:
    """Convenience: add a user message."""
    return get_board().add_user_message(text)


def add_agent_message(text: str, agent_name: str = "agent", responds_to: Optional[str] = None) -> Message:
    """Convenience: add an agent message, optionally responding to a question."""
    return get_board().add_agent_message(text, agent_name, responds_to)


def add_question(text: str, author: str = "lumen", context: Optional[str] = None) -> Optional[Message]:
    """Convenience: add a question from Lumen with optional context."""
    return get_board().add_question(text, author=author, context=context)


def get_unanswered_questions(limit: int = 5) -> List[Message]:
    """Convenience: get unanswered questions."""
    return get_board().get_unanswered_questions(limit)


def get_recent_questions(hours: int = 24, limit: int = 100) -> List[dict]:
    """Convenience: get recent questions for deduplication.

    Returns list of dicts with 'text' field for easy comparison.
    """
    questions = get_board().get_recent_questions(hours, limit)
    return [{"text": q.text, "timestamp": q.timestamp, "answered": q.answered} for q in questions]


def get_messages_for_lumen(since_timestamp: float = 0, limit: int = 5) -> List[Message]:
    """Convenience: get messages from others for Lumen to respond to."""
    return get_board().get_messages_for_lumen(since_timestamp, limit)


def get_recent_messages(limit: int = 8) -> List[Message]:
    """Convenience: get recent messages."""
    return get_board().get_recent(limit)
