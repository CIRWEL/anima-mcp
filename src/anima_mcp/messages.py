"""
Message Board - Storage for observations and user messages.

Messages are stored persistently so they survive reboots.
"""

import json
import time
import os
import uuid
from typing import List, Dict, Any, Optional
from dataclasses import dataclass, asdict
from pathlib import Path


# Message types
MESSAGE_TYPE_OBSERVATION = "observation"  # Auto-generated by Lumen
MESSAGE_TYPE_USER = "user"                # Left by user via MCP tool
MESSAGE_TYPE_AGENT = "agent"              # Left by AI agents
MESSAGE_TYPE_SYSTEM = "system"            # System events


def _get_persistent_path() -> Path:
    """Get persistent path for messages - survives reboots."""
    # Use ~/.anima/ directory for persistent data
    anima_dir = Path.home() / ".anima"
    anima_dir.mkdir(exist_ok=True)
    return anima_dir / "messages.json"


@dataclass
class Message:
    """A message on the board."""
    message_id: str  # Unique ID for referencing
    text: str  # Clean text - no prefixes
    msg_type: str  # observation, user, agent, system
    timestamp: float
    author: Optional[str] = None  # "user", "lumen", "agent_name", etc.

    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

    @classmethod
    def from_dict(cls, d: Dict[str, Any]) -> "Message":
        # Handle old messages without message_id
        if "message_id" not in d:
            import uuid
            d["message_id"] = str(uuid.uuid4())[:8]
        if "author" not in d:
            d["author"] = None
        return cls(**d)

    def age_str(self) -> str:
        """Human-readable age string."""
        age_seconds = time.time() - self.timestamp
        if age_seconds < 60:
            return "now"
        elif age_seconds < 3600:
            mins = int(age_seconds / 60)
            return f"{mins}m ago"
        elif age_seconds < 86400:
            hours = int(age_seconds / 3600)
            return f"{hours}h ago"
        else:
            days = int(age_seconds / 86400)
            return f"{days}d ago"


class MessageBoard:
    """Message board storage."""

    MAX_MESSAGES = 50  # Keep last N messages (increased for persistence)

    def __init__(self):
        self._messages_file = _get_persistent_path()
        self._messages: List[Message] = []
        self._last_load_time: float = 0.0
        self._file_mtime: float = 0.0
        self._load()

    def _load(self, force: bool = False):
        """Load messages from persistent storage."""
        # Check file modification time - only reload if changed
        if not force and self._messages_file.exists():
            current_mtime = self._messages_file.stat().st_mtime
            if current_mtime == self._file_mtime and self._messages:
                return  # No change, skip reload
        
        try:
            if self._messages_file.exists():
                data = json.loads(self._messages_file.read_text())
                self._messages = [Message.from_dict(m) for m in data.get("messages", [])]
                self._file_mtime = self._messages_file.stat().st_mtime
            else:
                self._messages = []
                self._file_mtime = 0.0
        except Exception as e:
            print(f"[MessageBoard] Load error: {e}", flush=True)
            self._messages = []
            self._file_mtime = 0.0

    def _save(self):
        """Save messages to persistent storage."""
        try:
            data = {"messages": [m.to_dict() for m in self._messages]}
            self._messages_file.write_text(json.dumps(data))
            # Update mtime tracking after save
            if self._messages_file.exists():
                self._file_mtime = self._messages_file.stat().st_mtime
        except Exception as e:
            print(f"[MessageBoard] Save error: {e}", flush=True)

    def add_message(self, text: str, msg_type: str = MESSAGE_TYPE_OBSERVATION, author: Optional[str] = None) -> Message:
        """Add a message to the board."""
        message_id = str(uuid.uuid4())[:8]  # Short unique ID
        msg = Message(
            message_id=message_id,
            text=text,  # Clean text - no prefixes
            msg_type=msg_type,
            timestamp=time.time(),
            author=author,
        )
        self._messages.append(msg)

        # Trim to max
        if len(self._messages) > self.MAX_MESSAGES:
            self._messages = self._messages[-self.MAX_MESSAGES:]

        self._save()
        return msg

    def add_observation(self, text: str, author: str = "lumen") -> Message:
        """Add an auto-generated observation from Lumen."""
        # Deduplication: Don't add if same text in last 5 messages
        recent_texts = [m.text for m in self._messages[-5:]]
        if text in recent_texts:
            return None  # Skip duplicate
        
        return self.add_message(text, MESSAGE_TYPE_OBSERVATION, author=author)

    def add_user_message(self, text: str) -> Message:
        """Add a user message."""
        return self.add_message(text, MESSAGE_TYPE_USER, author="user")
    
    def add_agent_message(self, text: str, agent_name: str = "agent") -> Message:
        """Add an agent message."""
        return self.add_message(text, MESSAGE_TYPE_AGENT, author=agent_name)

    def get_recent(self, limit: int = 8, msg_type: Optional[str] = None) -> List[Message]:
        """Get recent messages, newest first."""
        self._load()  # Smart reload - only if file changed
        messages = self._messages[-limit:]
        if msg_type:
            messages = [m for m in messages if m.msg_type == msg_type]
        return list(reversed(messages))
    
    def get_by_id(self, message_id: str) -> Optional[Message]:
        """Get a specific message by ID."""
        self._load()
        for msg in self._messages:
            if msg.message_id == message_id:
                return msg
        return None
    
    def delete_by_id(self, message_id: str) -> bool:
        """Delete a message by ID."""
        self._load(force=True)
        original_count = len(self._messages)
        self._messages = [m for m in self._messages if m.message_id != message_id]
        if len(self._messages) < original_count:
            self._save()
            return True
        return False

    def clear(self):
        """Clear all messages."""
        self._messages = []
        self._save()


# Singleton instance
_board: Optional[MessageBoard] = None


def get_board() -> MessageBoard:
    """Get the message board singleton."""
    global _board
    if _board is None:
        _board = MessageBoard()
    return _board


def add_observation(text: str, author: str = "lumen") -> Optional[Message]:
    """Convenience: add an observation from Lumen."""
    return get_board().add_observation(text, author=author)


def add_user_message(text: str) -> Message:
    """Convenience: add a user message."""
    return get_board().add_user_message(text)


def add_agent_message(text: str, agent_name: str = "agent") -> Message:
    """Convenience: add an agent message."""
    return get_board().add_agent_message(text, agent_name)


def get_recent_messages(limit: int = 8) -> List[Message]:
    """Convenience: get recent messages."""
    return get_board().get_recent(limit)
