"""
Message Board - Storage for observations and user messages.

Messages are stored persistently so they survive reboots.
"""

import json
import time
import os
import uuid
from typing import List, Dict, Any, Optional
from dataclasses import dataclass, asdict
from pathlib import Path


# Message types
MESSAGE_TYPE_OBSERVATION = "observation"  # Auto-generated by Lumen
MESSAGE_TYPE_QUESTION = "question"        # Questions from Lumen seeking response
MESSAGE_TYPE_USER = "user"                # Left by user via MCP tool
MESSAGE_TYPE_AGENT = "agent"              # Left by AI agents
MESSAGE_TYPE_SYSTEM = "system"            # System events


def _get_persistent_path() -> Path:
    """Get persistent path for messages - survives reboots."""
    # Use ~/.anima/ directory for persistent data
    anima_dir = Path.home() / ".anima"
    anima_dir.mkdir(exist_ok=True)
    return anima_dir / "messages.json"


@dataclass
class Message:
    """A message on the board."""
    message_id: str  # Unique ID for referencing
    text: str  # Clean text - no prefixes
    msg_type: str  # observation, user, agent, system, question
    timestamp: float
    author: Optional[str] = None  # "user", "lumen", "agent_name", etc.
    responds_to: Optional[str] = None  # message_id this responds to (for answers)
    answered: bool = False  # For questions: has this been answered?
    context: Optional[str] = None  # For questions: what triggered this question

    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)

    @classmethod
    def from_dict(cls, d: Dict[str, Any]) -> "Message":
        # Handle old messages without message_id
        if "message_id" not in d:
            import uuid
            d["message_id"] = str(uuid.uuid4())[:8]
        if "author" not in d:
            d["author"] = None
        if "responds_to" not in d:
            d["responds_to"] = None
        if "answered" not in d:
            d["answered"] = False
        if "context" not in d:
            d["context"] = None
        return cls(**d)

    def is_question(self) -> bool:
        """Check if this message is a question."""
        return self.msg_type == MESSAGE_TYPE_QUESTION

    def age_str(self) -> str:
        """Human-readable age string."""
        age_seconds = time.time() - self.timestamp
        if age_seconds < 60:
            return "now"
        elif age_seconds < 3600:
            mins = int(age_seconds / 60)
            return f"{mins}m ago"
        elif age_seconds < 86400:
            hours = int(age_seconds / 3600)
            return f"{hours}h ago"
        else:
            days = int(age_seconds / 86400)
            return f"{days}d ago"


class MessageBoard:
    """Message board storage with separate limits per message type."""

    # Separate limits prevent observations from pushing out questions/visitors
    MAX_OBSERVATIONS = 100  # Lumen's self-talk (frequent)
    MAX_QUESTIONS = 50      # Curiosity questions (rare, important)
    MAX_VISITORS = 50       # User/agent messages (important to keep)

    def __init__(self):
        self._messages_file = _get_persistent_path()
        self._messages: List[Message] = []
        self._last_load_time: float = 0.0
        self._file_mtime: float = 0.0
        self._load()

    def _load(self, force: bool = False):
        """Load messages from persistent storage."""
        # Check file modification time - only reload if changed
        if not force and self._messages_file.exists():
            current_mtime = self._messages_file.stat().st_mtime
            if current_mtime == self._file_mtime and self._messages:
                return  # No change, skip reload
        
        try:
            if self._messages_file.exists():
                data = json.loads(self._messages_file.read_text())
                self._messages = [Message.from_dict(m) for m in data.get("messages", [])]
                self._file_mtime = self._messages_file.stat().st_mtime
            else:
                self._messages = []
                self._file_mtime = 0.0
        except Exception as e:
            print(f"[MessageBoard] Load error: {e}", flush=True)
            self._messages = []
            self._file_mtime = 0.0

    def _save(self):
        """Save messages to persistent storage."""
        try:
            data = {"messages": [m.to_dict() for m in self._messages]}
            self._messages_file.write_text(json.dumps(data))
            # Update mtime tracking after save
            if self._messages_file.exists():
                self._file_mtime = self._messages_file.stat().st_mtime
        except Exception as e:
            print(f"[MessageBoard] Save error: {e}", flush=True)

    def add_message(self, text: str, msg_type: str = MESSAGE_TYPE_OBSERVATION, author: Optional[str] = None) -> Message:
        """Add a message to the board."""
        message_id = str(uuid.uuid4())[:8]  # Short unique ID
        msg = Message(
            message_id=message_id,
            text=text,  # Clean text - no prefixes
            msg_type=msg_type,
            timestamp=time.time(),
            author=author,
        )
        self._messages.append(msg)

        # Trim by type - each category has its own limit
        self._trim_by_type()

        self._save()
        return msg

    def _trim_by_type(self):
        """Trim messages by type, preserving limits for each category."""
        # Separate messages by type
        observations = [m for m in self._messages if m.msg_type == MESSAGE_TYPE_OBSERVATION]
        questions = [m for m in self._messages if m.msg_type == MESSAGE_TYPE_QUESTION]
        visitors = [m for m in self._messages if m.msg_type in (MESSAGE_TYPE_USER, MESSAGE_TYPE_AGENT)]

        # Trim each category to its limit (keep most recent)
        observations = observations[-self.MAX_OBSERVATIONS:]
        questions = questions[-self.MAX_QUESTIONS:]
        visitors = visitors[-self.MAX_VISITORS:]

        # Merge back and sort by timestamp
        self._messages = observations + questions + visitors
        self._messages.sort(key=lambda m: m.timestamp)

    def add_observation(self, text: str, author: str = "lumen") -> Message:
        """Add an auto-generated observation from Lumen.

        Deduplication strategy:
        1. Global rate limit: Max 1 observation per 5 minutes (prevents spam)
        2. Semantic similarity: Skip if >50% word overlap with recent obs
        3. Exact match: Skip identical text within 15 minutes
        """
        import time

        now = time.time()
        five_minutes_ago = now - 300
        fifteen_minutes_ago = now - 900

        # Get recent observations (last 20)
        recent_observations = [m for m in self._messages if m.msg_type == MESSAGE_TYPE_OBSERVATION][-20:]

        # === GLOBAL RATE LIMIT ===
        # Max 1 observation per 5 minutes to prevent chatter
        if recent_observations:
            last_obs = recent_observations[-1]
            if last_obs.timestamp > five_minutes_ago:
                return None  # Too soon since last observation

        # === EXACT MATCH CHECK ===
        for obs in recent_observations:
            if obs.text == text and obs.timestamp > fifteen_minutes_ago:
                return None  # Skip exact duplicate

        # === SEMANTIC SIMILARITY CHECK ===
        # Skip if new text is >50% similar to any recent observation
        def get_words(s: str) -> set:
            """Extract meaningful words (lowercase, no punctuation)."""
            import re
            # Remove punctuation, lowercase, split
            words = re.sub(r'[^\w\s]', '', s.lower()).split()
            # Filter out very short words and common filler
            stopwords = {'i', 'a', 'the', 'to', 'and', 'is', 'it', 'in', 'my', 'im', 'that', 'this'}
            return {w for w in words if len(w) > 2 and w not in stopwords}

        new_words = get_words(text)
        if new_words:  # Only check if we have meaningful words
            for obs in recent_observations[-10:]:  # Check last 10 observations
                obs_words = get_words(obs.text)
                if obs_words:
                    # Jaccard similarity
                    intersection = new_words & obs_words
                    union = new_words | obs_words
                    similarity = len(intersection) / len(union) if union else 0

                    if similarity > 0.50:  # More than 50% overlap
                        return None  # Too similar to recent observation

        return self.add_message(text, MESSAGE_TYPE_OBSERVATION, author=author)

    def add_user_message(self, text: str) -> Message:
        """Add a user message."""
        return self.add_message(text, MESSAGE_TYPE_USER, author="user")
    
    def add_agent_message(self, text: str, agent_name: str = "agent", responds_to: Optional[str] = None) -> Message:
        """Add an agent message, optionally responding to a question."""
        msg = self.add_message(text, MESSAGE_TYPE_AGENT, author=agent_name)
        if responds_to:
            msg.responds_to = responds_to
            # Find the question being answered
            question_text = None
            for m in self._messages:
                if m.message_id == responds_to and m.msg_type == MESSAGE_TYPE_QUESTION:
                    m.answered = True
                    question_text = m.text
                    break
            self._save()

            # Extract insight from Q&A (async, non-blocking)
            if question_text:
                try:
                    import asyncio
                    from .knowledge import extract_insight_from_answer

                    async def extract():
                        insight = await extract_insight_from_answer(question_text, text, agent_name)
                        if insight:
                            print(f"[Knowledge] Learned: {insight.text}", flush=True)

                    # Schedule extraction without blocking
                    try:
                        loop = asyncio.get_running_loop()
                        loop.create_task(extract())
                    except RuntimeError:
                        # No running loop, run synchronously
                        asyncio.run(extract())
                except Exception as e:
                    print(f"[Knowledge] Extraction scheduling failed: {e}", flush=True)

        return msg

    def add_question(self, text: str, author: str = "lumen", context: Optional[str] = None) -> Optional[Message]:
        """Add a question from Lumen - seeking response from agents/user.

        Args:
            text: The question text
            author: Who is asking (default: "lumen")
            context: What triggered this question (e.g., "light dropped suddenly")
        """
        import time

        # Deduplication: Don't ask similar questions within 1 hour
        now = time.time()
        one_hour_ago = now - 3600

        recent_questions = [m for m in self._messages if m.msg_type == MESSAGE_TYPE_QUESTION][-20:]
        for q in recent_questions:
            if q.timestamp > one_hour_ago:
                # Check for exact or similar questions
                if self._questions_similar(text, q.text):
                    return None  # Skip similar question

        msg = self.add_message(text, MESSAGE_TYPE_QUESTION, author=author)
        if msg and context:
            msg.context = context
            self._save()
        return msg

    def _questions_similar(self, q1: str, q2: str) -> bool:
        """Check if two questions are similar (fuzzy matching).

        Returns True if questions are too similar to ask again.
        """
        # Normalize: lowercase, strip punctuation
        def normalize(s: str) -> str:
            return s.lower().strip().rstrip("?!.")

        n1, n2 = normalize(q1), normalize(q2)

        # Exact match after normalization
        if n1 == n2:
            return True

        # Check word overlap (Jaccard similarity > 0.6 = too similar)
        words1 = set(n1.split())
        words2 = set(n2.split())
        if not words1 or not words2:
            return n1 == n2

        intersection = words1 & words2
        union = words1 | words2
        jaccard = len(intersection) / len(union) if union else 0

        if jaccard > 0.6:
            return True

        # Check for common question stems (prevents "what connects X" repetition)
        stems = [
            "what connects",
            "why did so many",
            "what changed",
            "why did it get",
            "what caused",
            "how are these",
        ]
        for stem in stems:
            if stem in n1 and stem in n2:
                return True

        return False

    def get_unanswered_questions(self, limit: int = 5, auto_expire: bool = True) -> List[Message]:
        """Get unanswered questions for agents to respond to.

        Args:
            limit: Max questions to return
            auto_expire: If True, mark questions older than 1 hour as expired (answered=True)
        """
        self._load()

        # Auto-expire old questions so Lumen can ask new ones
        if auto_expire:
            now = time.time()
            one_hour_ago = now - 3600  # 1 hour expiry
            expired_any = False
            for m in self._messages:
                if (m.msg_type == MESSAGE_TYPE_QUESTION and
                    not m.answered and
                    m.timestamp < one_hour_ago):
                    m.answered = True  # Mark as expired/answered
                    expired_any = True
                    print(f"[Questions] Expired old question: {m.text[:50]}...", flush=True)
            if expired_any:
                self._save()

        questions = [m for m in self._messages if m.msg_type == MESSAGE_TYPE_QUESTION and not m.answered]
        return questions[-limit:]

    def get_messages_for_lumen(self, since_timestamp: float = 0, limit: int = 5) -> List[Message]:
        """Get messages from agents/users that Lumen might want to respond to."""
        self._load()
        # Messages from others (not Lumen's own observations/questions)
        from_others = [
            m for m in self._messages
            if m.msg_type in (MESSAGE_TYPE_USER, MESSAGE_TYPE_AGENT)
            and m.timestamp > since_timestamp
            and m.author != "lumen"
        ]
        return from_others[-limit:]

    def get_recent(self, limit: int = 8, msg_type: Optional[str] = None) -> List[Message]:
        """Get recent messages, newest first."""
        self._load()  # Smart reload - only if file changed
        messages = self._messages[-limit:]
        if msg_type:
            messages = [m for m in messages if m.msg_type == msg_type]
        return list(reversed(messages))
    
    def get_by_id(self, message_id: str) -> Optional[Message]:
        """Get a specific message by ID."""
        self._load()
        for msg in self._messages:
            if msg.message_id == message_id:
                return msg
        return None
    
    def delete_by_id(self, message_id: str) -> bool:
        """Delete a message by ID."""
        self._load(force=True)
        original_count = len(self._messages)
        self._messages = [m for m in self._messages if m.message_id != message_id]
        if len(self._messages) < original_count:
            self._save()
            return True
        return False

    def clear(self):
        """Clear all messages."""
        self._messages = []
        self._save()


# Singleton instance
_board: Optional[MessageBoard] = None


def get_board() -> MessageBoard:
    """Get the message board singleton."""
    global _board
    if _board is None:
        _board = MessageBoard()
    return _board


def add_observation(text: str, author: str = "lumen") -> Optional[Message]:
    """Convenience: add an observation from Lumen."""
    return get_board().add_observation(text, author=author)


def add_user_message(text: str) -> Message:
    """Convenience: add a user message."""
    return get_board().add_user_message(text)


def add_agent_message(text: str, agent_name: str = "agent", responds_to: Optional[str] = None) -> Message:
    """Convenience: add an agent message, optionally responding to a question."""
    return get_board().add_agent_message(text, agent_name, responds_to)


def add_question(text: str, author: str = "lumen", context: Optional[str] = None) -> Optional[Message]:
    """Convenience: add a question from Lumen with optional context."""
    return get_board().add_question(text, author=author, context=context)


def get_unanswered_questions(limit: int = 5) -> List[Message]:
    """Convenience: get unanswered questions."""
    return get_board().get_unanswered_questions(limit)


def get_messages_for_lumen(since_timestamp: float = 0, limit: int = 5) -> List[Message]:
    """Convenience: get messages from others for Lumen to respond to."""
    return get_board().get_messages_for_lumen(since_timestamp, limit)


def get_recent_messages(limit: int = 8) -> List[Message]:
    """Convenience: get recent messages."""
    return get_board().get_recent(limit)
