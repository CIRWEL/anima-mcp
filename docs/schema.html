<!DOCTYPE html>
<html lang="en">
<!--
    Lumen Self-Schema - G_t Graph Visualization
    Live visualization of the full self-schema graph and trajectory identity.
    Served at /schema
-->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lumen Self-Schema</title>
    <link rel="stylesheet" href="/static/shared.css">
    <style>
        body {
            background: #0c0c0f;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            max-width: 600px;
            width: 100%;
            padding: 32px 24px;
        }

        /* Header */
        .header { margin-bottom: 24px; text-align: center; }
        .header-label {
            font-size: 9px; color: var(--text-dim); font-family: var(--mono);
            letter-spacing: 0.15em; text-transform: uppercase; margin-bottom: 6px;
        }
        .header-title {
            font-size: 18px; font-weight: 300; color: var(--text-bright);
            letter-spacing: 0.02em;
        }
        .header-status {
            display: flex; align-items: center; justify-content: center;
            gap: 8px; margin-top: 8px;
        }
        .header-status-text {
            font-size: 10px; color: var(--text-dim); font-family: var(--mono);
        }

        :root {
            --text-bright: rgba(255,255,255,0.9);
            --text-mid: rgba(255,255,255,0.6);
            --text-dim: rgba(255,255,255,0.35);
            --text-faint: rgba(255,255,255,0.2);
            --text-ghost: rgba(255,255,255,0.08);
            --c-identity: #e8c87c;
            --c-anima: #f0b87a;
            --c-sensor: #8bb8e8;
            --c-resource: #8bb8e8;
            --c-preference: #7ecfcf;
            --c-belief: #c49be8;
            --c-trajectory: #7ecf8b;
            --c-meta: rgba(255,255,255,0.3);
            --c-drift: #e8a87c;
            --c-tension: #e87c7c;
        }

        /* Pulse dot */
        .pulse-dot {
            width: 6px; height: 6px; border-radius: 50%;
            animation: pulse-glow 2s ease-in-out infinite;
        }
        @keyframes pulse-glow {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Count badge */
        .count-badge {
            display: inline-block;
            font-size: 9px; font-family: var(--mono);
            color: var(--text-dim);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 10px;
            padding: 2px 8px;
            margin-left: 8px;
        }

        /* Graph canvas */
        .graph-section {
            background: rgba(255,255,255,0.02);
            border: 1px solid rgba(255,255,255,0.06);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
            position: relative;
        }
        .graph-section-label {
            font-size: 9px; color: var(--text-dim); font-family: var(--mono);
            letter-spacing: 0.1em; text-transform: uppercase; margin-bottom: 12px;
        }
        #graphCanvas {
            width: 100%;
            border-radius: 8px;
            cursor: crosshair;
            display: block;
        }

        /* Node detail panel */
        .node-detail {
            display: none;
            margin-top: 12px;
            padding: 12px 16px;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 8px;
            font-size: 11px;
            font-family: var(--mono);
        }
        .node-detail.visible { display: block; }
        .node-detail-type {
            font-size: 9px; text-transform: uppercase; letter-spacing: 0.1em;
            margin-bottom: 4px;
        }
        .node-detail-label {
            font-size: 13px; color: var(--text-bright); margin-bottom: 8px;
        }
        .node-detail-value {
            color: var(--text-mid); font-size: 11px;
        }
        .node-detail-raw {
            margin-top: 8px; color: var(--text-dim); font-size: 10px;
            white-space: pre-wrap; word-break: break-all;
            max-height: 120px; overflow-y: auto;
        }

        /* Trajectory panel */
        .traj-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 16px;
        }
        .traj-card {
            background: rgba(255,255,255,0.02);
            border: 1px solid rgba(255,255,255,0.06);
            border-radius: 10px;
            padding: 12px 14px;
            position: relative;
            overflow: hidden;
        }
        .traj-card.full-width {
            grid-column: 1 / -1;
        }
        .traj-card-glow {
            position: absolute; top: 0; left: 0; right: 0; height: 1px;
            background: linear-gradient(90deg, transparent, var(--c-trajectory), transparent);
            opacity: 0.4;
        }
        .traj-card-title {
            font-size: 9px; font-family: var(--mono); color: var(--text-dim);
            letter-spacing: 0.1em; text-transform: uppercase; margin-bottom: 8px;
        }
        .traj-card-symbol {
            color: var(--c-trajectory); margin-right: 4px;
        }

        /* Metric bars (reused) */
        .metric-bar { width: 100%; margin-bottom: 6px; }
        .metric-bar:last-child { margin-bottom: 0; }
        .metric-header {
            display: flex; justify-content: space-between; align-items: baseline;
            margin-bottom: 3px;
        }
        .metric-label { font-size: 10px; color: rgba(255,255,255,0.5); }
        .metric-value { font-size: 11px; color: rgba(255,255,255,0.8); font-family: var(--mono); }
        .metric-track { height: 3px; background: rgba(255,255,255,0.06); border-radius: 2px; }
        .metric-fill { height: 100%; border-radius: 2px; transition: width 1s ease; }

        /* Belief list */
        .belief-item {
            display: flex; align-items: center; gap: 8px;
            padding: 3px 0;
        }
        .belief-name {
            font-size: 10px; color: var(--text-mid);
            flex: 1; min-width: 0;
            overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
        }
        .belief-bar {
            width: 50px; height: 3px;
            background: rgba(255,255,255,0.06); border-radius: 2px;
            flex-shrink: 0;
        }
        .belief-fill {
            height: 100%; border-radius: 2px;
            background: var(--c-belief);
        }
        .belief-evidence {
            font-size: 9px; color: var(--text-faint); font-family: var(--mono);
            width: 20px; text-align: right; flex-shrink: 0;
        }

        /* History strip */
        .history-strip {
            background: rgba(255,255,255,0.02);
            border: 1px solid rgba(255,255,255,0.06);
            border-radius: 12px;
            padding: 12px 16px;
            margin-bottom: 16px;
        }
        .history-strip-label {
            font-size: 9px; color: var(--text-dim); font-family: var(--mono);
            letter-spacing: 0.1em; text-transform: uppercase; margin-bottom: 8px;
        }
        #historyCanvas {
            width: 100%;
            height: 40px;
            display: block;
        }
        .history-tooltip {
            display: none;
            position: absolute;
            background: rgba(13,13,18,0.95);
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 10px; font-family: var(--mono);
            color: var(--text-mid);
            pointer-events: none;
            z-index: 100;
            white-space: nowrap;
        }

        /* Gap & drift section */
        .gap-section {
            background: rgba(255,255,255,0.02);
            border: 1px solid rgba(255,255,255,0.06);
            border-radius: 12px;
            padding: 12px 16px;
            margin-bottom: 16px;
        }
        .gap-badge {
            display: inline-block;
            font-size: 10px; font-family: var(--mono);
            color: var(--c-drift);
            border: 1px solid rgba(232,168,124,0.3);
            border-radius: 10px;
            padding: 2px 10px;
            margin-bottom: 8px;
        }
        .drift-node {
            display: flex; align-items: center; gap: 8px;
            padding: 4px 0;
        }
        .drift-dot {
            width: 6px; height: 6px; border-radius: 50%;
            flex-shrink: 0;
        }
        .drift-label {
            font-size: 10px; color: var(--text-mid); flex: 1;
        }
        .drift-value {
            font-size: 10px; font-family: var(--mono); color: var(--text-dim);
        }

        /* Footer */
        .footer { text-align: center; margin-top: 24px; padding-bottom: 32px; }
        .footer-text { font-size: 9px; color: var(--text-faint); font-family: var(--mono); }

        /* Skeleton */
        .skeleton-graph {
            height: 360px;
            border-radius: 8px;
            background: linear-gradient(90deg, rgba(255,255,255,0.02) 25%, rgba(255,255,255,0.04) 50%, rgba(255,255,255,0.02) 75%);
            background-size: 200% 100%;
            animation: skeleton-shimmer 1.5s ease-in-out infinite;
        }
        @keyframes skeleton-shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        /* No data state */
        .no-data {
            padding: 60px 20px;
            font-family: var(--mono);
            font-size: 12px;
            color: var(--text-dim);
            text-align: center;
        }

        /* Responsive */
        @media (max-width: 500px) {
            .container { padding: 20px 16px; }
            .traj-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="header-label">Self-Model Graph</div>
            <div class="header-title">Self-Schema G<sub>t</sub></div>
            <div class="header-status">
                <div class="pulse-dot" id="statusDot" style="background-color: var(--c-trajectory);"></div>
                <span class="header-status-text" id="statusText">loading...</span>
            </div>
        </div>

        <div id="content">
            <div class="graph-section">
                <div class="skeleton-graph"></div>
            </div>
        </div>

        <div class="footer">
            <div class="footer-text">Schema &middot; History &middot; Trajectory &middot; Circulation</div>
        </div>
    </div>

    <div class="history-tooltip" id="historyTooltip"></div>

    <script src="/static/shared.js"></script>
    <script>
        // ── State ──
        let data = null;
        let selectedNode = null;
        let nodePositions = []; // {x, y, r, node} for hit testing
        const TYPE_COLORS = {
            identity:   '#e8c87c',
            anima:      '#f0b87a',
            sensor:     '#8bb8e8',
            resource:   '#8bb8e8',
            preference: '#7ecfcf',
            belief:     '#c49be8',
            trajectory: '#7ecf8b',
            meta:       'rgba(255,255,255,0.3)',
            drift:      '#e8a87c',
            tension:    '#e87c7c',
        };
        const TYPE_RINGS = {
            identity:   0,
            anima:      1,
            sensor:     2,
            resource:   2,
            preference: 3,
            belief:     3,
            trajectory: 4,
            meta:       4,
            drift:      4,
            tension:    4,
        };

        // ── Fetch ──
        async function fetchSchema() {
            try {
                const response = await fetch(`${API_BASE}/schema-data`);
                data = await response.json();
                if (data.error) {
                    document.getElementById('content').innerHTML =
                        `<div class="no-data">Error: ${escapeHtml(data.error)}</div>`;
                    return;
                }
                render(data);
            } catch (e) {
                document.getElementById('content').innerHTML =
                    `<div class="no-data">Connection lost. Is Lumen running?</div>`;
            }
        }

        // ── Main render ──
        function render(d) {
            const schema = d.schema;
            const traj = d.trajectory;
            const history = d.history || [];
            const gap = d.gap;

            // Status line
            if (schema) {
                const ts = new Date(schema.timestamp);
                const timeStr = ts.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                document.getElementById('statusText').textContent =
                    `${timeStr} \u00b7 ${schema.node_count} nodes \u00b7 ${schema.edge_count} edges`;
                document.getElementById('statusDot').style.backgroundColor = 'var(--c-trajectory)';
            } else {
                document.getElementById('statusText').textContent = 'no schema yet';
                document.getElementById('statusDot').style.backgroundColor = 'var(--text-faint)';
            }

            let html = '';

            // A. Graph section
            html += `<div class="graph-section">
                <div class="graph-section-label">Graph</div>
                <canvas id="graphCanvas" width="552" height="400"></canvas>
                <div class="node-detail" id="nodeDetail">
                    <div class="node-detail-type" id="ndType"></div>
                    <div class="node-detail-label" id="ndLabel"></div>
                    <div class="node-detail-value" id="ndValue"></div>
                    <div class="node-detail-raw" id="ndRaw"></div>
                </div>
            </div>`;

            // B. Trajectory
            if (traj) {
                html += renderTrajectory(traj);
            }

            // C. History strip
            if (history.length > 0) {
                html += `<div class="history-strip" style="position:relative;">
                    <div class="history-strip-label">History (${history.length} snapshots)</div>
                    <canvas id="historyCanvas" width="552" height="40"></canvas>
                </div>`;
            }

            // D. Gap & drift
            const driftNodes = schema ? schema.nodes.filter(n => n.type === 'drift' || n.type === 'tension') : [];
            if (gap || driftNodes.length > 0) {
                html += renderGapDrift(gap, driftNodes);
            }

            document.getElementById('content').innerHTML = html;

            // Draw canvases after DOM update
            if (schema) drawGraph(schema);
            if (history.length > 0) drawHistory(history);
        }

        // ── Graph drawing ──
        function drawGraph(schema) {
            const canvas = document.getElementById('graphCanvas');
            if (!canvas) return;
            const dpr = window.devicePixelRatio || 1;
            const w = canvas.clientWidth;
            const h = 400;
            canvas.width = w * dpr;
            canvas.height = h * dpr;
            canvas.style.height = h + 'px';
            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);

            const cx = w / 2;
            const cy = h / 2;
            const maxR = Math.min(cx, cy) - 30;
            const ringRadii = [0, maxR * 0.22, maxR * 0.44, maxR * 0.66, maxR * 0.88];

            // Group nodes by ring
            const rings = [[], [], [], [], []];
            const nodeMap = {};
            schema.nodes.forEach(n => {
                const ring = TYPE_RINGS[n.type] !== undefined ? TYPE_RINGS[n.type] : 4;
                rings[ring].push(n);
                nodeMap[n.id] = n;
            });

            // Position nodes
            nodePositions = [];
            const posMap = {};
            rings.forEach((ringNodes, ri) => {
                const radius = ringRadii[ri];
                ringNodes.forEach((n, i) => {
                    let x, y;
                    if (ri === 0) {
                        x = cx; y = cy;
                    } else {
                        const angle = (2 * Math.PI * i / ringNodes.length) - Math.PI / 2;
                        x = cx + radius * Math.cos(angle);
                        y = cy + radius * Math.sin(angle);
                    }
                    const nr = 8 + (n.value || 0) * 12;
                    posMap[n.id] = { x, y, r: nr };
                    nodePositions.push({ x, y, r: nr, node: n });
                });
            });

            // Draw edges
            schema.edges.forEach(e => {
                const src = posMap[e.source];
                const tgt = posMap[e.target];
                if (!src || !tgt) return;
                const w = Math.abs(e.weight);
                ctx.beginPath();
                ctx.moveTo(src.x, src.y);
                ctx.lineTo(tgt.x, tgt.y);
                ctx.strokeStyle = e.weight >= 0
                    ? `rgba(126,207,139,${w * 0.6})`
                    : `rgba(232,124,124,${w * 0.6})`;
                ctx.lineWidth = 0.5 + w * 1.5;
                ctx.stroke();
            });

            // Draw ring guides
            ringRadii.slice(1).forEach(r => {
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, 2 * Math.PI);
                ctx.strokeStyle = 'rgba(255,255,255,0.03)';
                ctx.lineWidth = 1;
                ctx.stroke();
            });

            // Draw nodes
            nodePositions.forEach(({ x, y, r, node }) => {
                const color = TYPE_COLORS[node.type] || 'rgba(255,255,255,0.3)';
                // Glow
                ctx.beginPath();
                ctx.arc(x, y, r + 4, 0, 2 * Math.PI);
                ctx.fillStyle = color.replace(')', ',0.1)').replace('rgba', 'rgba').replace('rgb(', 'rgba(');
                // Simpler glow approach
                ctx.globalAlpha = 0.15;
                ctx.fillStyle = color;
                ctx.fill();
                ctx.globalAlpha = 1;

                // Node fill
                ctx.beginPath();
                ctx.arc(x, y, r, 0, 2 * Math.PI);
                ctx.fillStyle = color;
                ctx.globalAlpha = 0.8;
                ctx.fill();
                ctx.globalAlpha = 1;

                // Selected highlight
                if (selectedNode && selectedNode.id === node.id) {
                    ctx.beginPath();
                    ctx.arc(x, y, r + 2, 0, 2 * Math.PI);
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }

                // Label for larger nodes or identity
                if (r > 12 || node.type === 'identity') {
                    ctx.fillStyle = 'rgba(255,255,255,0.8)';
                    ctx.font = '9px "DM Mono", monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillText(truncLabel(node.label), x, y + r + 4);
                }
            });

            // Click handler
            canvas.onclick = function(evt) {
                const rect = canvas.getBoundingClientRect();
                const mx = evt.clientX - rect.left;
                const my = evt.clientY - rect.top;
                let hit = null;
                let minDist = Infinity;
                nodePositions.forEach(p => {
                    const dx = mx - p.x;
                    const dy = my - p.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < p.r + 6 && dist < minDist) {
                        minDist = dist;
                        hit = p.node;
                    }
                });
                if (hit) {
                    selectedNode = hit;
                    showNodeDetail(hit);
                    drawGraph(data.schema);
                } else {
                    selectedNode = null;
                    document.getElementById('nodeDetail').classList.remove('visible');
                    drawGraph(data.schema);
                }
            };
        }

        function truncLabel(s) {
            if (!s) return '';
            return s.length > 14 ? s.slice(0, 12) + '\u2026' : s;
        }

        function showNodeDetail(node) {
            const panel = document.getElementById('nodeDetail');
            const color = TYPE_COLORS[node.type] || '#888';
            document.getElementById('ndType').textContent = node.type;
            document.getElementById('ndType').style.color = color;
            document.getElementById('ndLabel').textContent = node.label;
            document.getElementById('ndValue').textContent = typeof node.value === 'number'
                ? `value: ${node.value.toFixed(3)}` : `value: ${node.value}`;
            const raw = node.raw_value;
            if (raw !== null && raw !== undefined && raw !== node.value) {
                document.getElementById('ndRaw').textContent =
                    typeof raw === 'object' ? JSON.stringify(raw, null, 2) : String(raw);
                document.getElementById('ndRaw').style.display = 'block';
            } else {
                document.getElementById('ndRaw').style.display = 'none';
            }
            panel.classList.add('visible');
        }

        // ── Trajectory panel ──
        function renderTrajectory(t) {
            let html = '<div class="traj-grid">';

            // Overview card
            html += trajCard('\u03a3', 'Overview', true, `
                ${metricBar('identity confidence', t.identity_confidence, 1, 'var(--c-trajectory)')}
                ${metricBar('stability', t.stability_score, 1, 'var(--c-trajectory)')}
                ${t.lineage_similarity !== null ? metricBar('lineage similarity', t.lineage_similarity, 1, 'var(--c-identity)') : ''}
                <div style="margin-top:4px;font-size:10px;color:var(--text-dim);font-family:var(--mono)">
                    ${t.observation_count} observations${t.has_genesis ? ' \u00b7 genesis anchored' : ''}
                </div>
            `);

            // Preferences card
            const prefs = t.preferences_detail || {};
            let prefsContent = `<div style="font-size:10px;color:var(--text-mid);margin-bottom:4px">${t.preferences_learned || 0} learned</div>`;
            if (prefs.preference_vector) {
                const pv = prefs.preference_vector;
                Object.keys(pv).forEach(k => {
                    prefsContent += miniBar(k, pv[k], 'var(--c-preference)');
                });
            } else if (prefs.dimensions) {
                Object.keys(prefs.dimensions).forEach(k => {
                    const v = prefs.dimensions[k];
                    prefsContent += miniBar(k, typeof v === 'number' ? v : (v.mean || 0), 'var(--c-preference)');
                });
            }
            html += trajCard('\u03a0', 'Preferences', false, prefsContent);

            // Beliefs card
            const beliefs = t.beliefs_detail || {};
            let beliefsContent = '';
            const beliefValues = beliefs.values || beliefs.beliefs || {};
            const beliefKeys = Object.keys(beliefValues).slice(0, 8);
            if (beliefKeys.length > 0) {
                beliefKeys.forEach(k => {
                    const b = beliefValues[k];
                    const conf = typeof b === 'number' ? b : (b.confidence || 0);
                    const ev = typeof b === 'object' ? (b.evidence_count || b.n_evidence || 0) : '';
                    beliefsContent += `<div class="belief-item">
                        <span class="belief-name">${escapeHtml(k)}</span>
                        <div class="belief-bar"><div class="belief-fill" style="width:${(conf*100).toFixed(0)}%"></div></div>
                        ${ev !== '' ? `<span class="belief-evidence">${ev}</span>` : ''}
                    </div>`;
                });
            } else {
                beliefsContent = `<div style="font-size:10px;color:var(--text-faint)">avg confidence: ${(t.belief_confidence || 0).toFixed(2)}</div>`;
            }
            html += trajCard('\u0392', 'Beliefs', false, beliefsContent);

            // Attractor card
            const attr = t.attractor_detail;
            let attrContent = '';
            if (attr && attr.center) {
                const dims = ['warmth', 'clarity', 'stability', 'presence'];
                const center = attr.center;
                const variance = attr.variance || [];
                dims.forEach((d, i) => {
                    const c = Array.isArray(center) ? center[i] : (center[d] || 0);
                    const v = Array.isArray(variance) ? variance[i] : (variance[d] || 0);
                    attrContent += `<div style="display:flex;align-items:center;gap:6px;padding:2px 0">
                        <span style="font-size:10px;color:var(--text-mid);width:55px">${d}</span>
                        <div style="flex:1;height:3px;background:rgba(255,255,255,0.06);border-radius:2px">
                            <div style="height:100%;width:${(c*100).toFixed(0)}%;background:var(--c-anima);border-radius:2px"></div>
                        </div>
                        <span style="font-size:9px;font-family:var(--mono);color:var(--text-faint);width:28px;text-align:right">\u00b1${v.toFixed(2)}</span>
                    </div>`;
                });
            } else {
                attrContent = `<div style="font-size:10px;color:var(--text-faint)">${t.attractor_defined ? 'defined' : 'not yet computed'}</div>`;
            }
            html += trajCard('\u0391', 'Attractor', false, attrContent);

            // Recovery card
            const rec = t.recovery_detail || {};
            let recContent = '';
            if (t.recovery_tau !== null && t.recovery_tau !== undefined) {
                recContent += `<div style="font-size:12px;color:var(--text-mid);font-family:var(--mono);margin-bottom:4px">\u03c4 = ${t.recovery_tau.toFixed(2)}</div>`;
            }
            if (rec.decay_times) {
                Object.keys(rec.decay_times).forEach(k => {
                    recContent += miniBar(k, Math.min(rec.decay_times[k] / 100, 1), 'var(--c-trajectory)');
                });
            } else if (rec.per_dimension) {
                Object.keys(rec.per_dimension).forEach(k => {
                    const v = rec.per_dimension[k];
                    recContent += miniBar(k, Math.min((typeof v === 'number' ? v : v.tau || 0) / 100, 1), 'var(--c-trajectory)');
                });
            }
            if (!recContent) recContent = `<div style="font-size:10px;color:var(--text-faint)">awaiting perturbation data</div>`;
            html += trajCard('\u03a1', 'Recovery', false, recContent);

            // Relational card
            const rel = t.relational_detail || {};
            let relContent = '';
            if (rel.valence_tendency !== undefined) {
                relContent += metricBar('valence tendency', Math.abs(rel.valence_tendency), 1,
                    rel.valence_tendency >= 0 ? 'var(--c-trajectory)' : 'var(--c-drift)');
            }
            relContent += `<div style="font-size:10px;color:var(--text-dim);font-family:var(--mono);margin-top:2px">${t.relationships || 0} relationships</div>`;
            html += trajCard('\u0394', 'Relational', false, relContent);

            html += '</div>';
            return html;
        }

        function trajCard(symbol, title, fullWidth, content) {
            return `<div class="traj-card${fullWidth ? ' full-width' : ''}">
                <div class="traj-card-glow"></div>
                <div class="traj-card-title"><span class="traj-card-symbol">${symbol}</span>${title}</div>
                ${content}
            </div>`;
        }

        function metricBar(label, value, max, color) {
            const pct = Math.min((value / max) * 100, 100);
            return `<div class="metric-bar">
                <div class="metric-header">
                    <span class="metric-label">${label}</span>
                    <span class="metric-value">${typeof value === 'number' ? value.toFixed(3) : value}</span>
                </div>
                <div class="metric-track">
                    <div class="metric-fill" style="width:${pct}%;background:${color}"></div>
                </div>
            </div>`;
        }

        function miniBar(label, value, color) {
            const pct = Math.min(Math.abs(value) * 100, 100);
            return `<div style="display:flex;align-items:center;gap:6px;padding:1px 0">
                <span style="font-size:9px;color:var(--text-dim);width:55px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">${escapeHtml(label)}</span>
                <div style="flex:1;height:2px;background:rgba(255,255,255,0.06);border-radius:1px">
                    <div style="height:100%;width:${pct.toFixed(0)}%;background:${color};border-radius:1px"></div>
                </div>
                <span style="font-size:9px;font-family:var(--mono);color:var(--text-faint);width:28px;text-align:right">${value.toFixed(2)}</span>
            </div>`;
        }

        // ── History strip ──
        function drawHistory(history) {
            const canvas = document.getElementById('historyCanvas');
            if (!canvas) return;
            const dpr = window.devicePixelRatio || 1;
            const w = canvas.clientWidth;
            const h = 40;
            canvas.width = w * dpr;
            canvas.height = h * dpr;
            canvas.style.height = h + 'px';
            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);

            const points = history.slice(-100);
            if (points.length === 0) return;

            const maxNodes = Math.max(...points.map(p => p.node_count), 1);
            const step = w / Math.max(points.length - 1, 1);

            // Draw line
            ctx.beginPath();
            points.forEach((p, i) => {
                const x = i * step;
                const y = h - 4 - (p.node_count / maxNodes) * (h - 8);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.strokeStyle = 'rgba(126,207,139,0.3)';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Draw dots
            const dotPositions = [];
            points.forEach((p, i) => {
                const x = i * step;
                const y = h - 4 - (p.node_count / maxNodes) * (h - 8);
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, 2 * Math.PI);
                ctx.fillStyle = 'rgba(126,207,139,0.6)';
                ctx.fill();
                dotPositions.push({ x, y, point: p });
            });

            // Hover tooltip
            const tooltip = document.getElementById('historyTooltip');
            const stripEl = canvas.closest('.history-strip');

            canvas.onmousemove = function(evt) {
                const rect = canvas.getBoundingClientRect();
                const mx = evt.clientX - rect.left;
                let closest = null;
                let minDist = 20;
                dotPositions.forEach(dp => {
                    const d = Math.abs(mx - dp.x);
                    if (d < minDist) { minDist = d; closest = dp; }
                });
                if (closest) {
                    const ts = new Date(closest.point.timestamp);
                    const timeStr = ts.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    tooltip.textContent = `${timeStr} \u00b7 ${closest.point.node_count}n ${closest.point.edge_count}e`;
                    tooltip.style.display = 'block';
                    tooltip.style.left = (rect.left + closest.x - tooltip.offsetWidth / 2) + 'px';
                    tooltip.style.top = (rect.top - 28) + 'px';
                } else {
                    tooltip.style.display = 'none';
                }
            };
            canvas.onmouseleave = function() { tooltip.style.display = 'none'; };
        }

        // ── Gap & Drift ──
        function renderGapDrift(gap, driftNodes) {
            let html = '<div class="gap-section">';
            html += '<div class="graph-section-label">Gap & Drift</div>';

            if (gap) {
                html += `<div class="gap-badge">${gap.was_gap ? 'gap' : 'first schema'} \u00b7 ${gap.duration_hours.toFixed(1)}h</div>`;
                if (gap.anima_delta) {
                    Object.keys(gap.anima_delta).forEach(k => {
                        const v = gap.anima_delta[k];
                        html += miniBar(k, Math.min(Math.abs(v), 1), v >= 0 ? 'var(--c-trajectory)' : 'var(--c-drift)');
                    });
                }
            }

            if (driftNodes.length > 0) {
                html += '<div style="margin-top:8px">';
                driftNodes.forEach(n => {
                    const color = n.type === 'drift' ? 'var(--c-drift)' : 'var(--c-tension)';
                    html += `<div class="drift-node">
                        <div class="drift-dot" style="background:${color}"></div>
                        <span class="drift-label">${escapeHtml(n.label)}</span>
                        <span class="drift-value">${typeof n.value === 'number' ? n.value.toFixed(3) : n.value}</span>
                    </div>`;
                });
                html += '</div>';
            }

            html += '</div>';
            return html;
        }

        // ── Init ──
        initNav('schema');
        fetchSchema();
        setInterval(fetchSchema, 30000);
    </script>
</body>
</html>
